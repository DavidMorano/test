/* libutil MODULE */
/* charset=ISO8859-1 */
/* lang=C++20 (conformance reviewed) */

/* UNIX® kernel support subroutines */
/* version %I% last-modified %G% */


/* Copyright © 1998 David A­D­ Morano.  All rights reserved. */

module ;

#include	<envstandards.h>	/* ordered first to configure */
#include	<climits>		/* |INT_MAX| */
#include	<cstddef>		/* |nullptr_t| */
#include	<cstdlib>
#include	<cstring>		/* |strlen(3c)| + |strnlen(3c)| */
#include	<clanguage.h>
#include	<utypedefs.h>
#include	<utypealiases.h>
#include	<usysdefs.h>

export module libutil ;

export {
    constexpr inline char *strcopy(char *dp,cchar *sp,int sl = -1) noex {
	char	*rp ;
	if (sl >= 0) {
	    csize ssize = size_t(sl) ;
	    rp = stpncpy(dp,sp,ssize) ;
	} else {
	    rp = stpcpy(dp,sp) ;
	}
	return rp ;
    }
    constexpr inline int cstrnlen(cchar *sp,int sl = -1) noex {
    	cchar		*cp = sp ;
	while (sl && *cp++) {
	    sl -= 1 ;
	}
	return int(cp - sp) ;
    }
    constexpr inline int cstrlen(cchar *sp) noex {
    	int		len = 0 ;
	while (sp[len]) len += 1 ;
	return len ;
    }
    constexpr inline int xstrnlen(cchar *sp,int sl) noex {
    	int		len = 0 ;
	if (sl >= 0) {
    	    csize	ssize = size_t(sl) ;
	    len = intconv(strnlen(sp,ssize)) ;
	} else {
	    len = intconv(strlen(sp)) ;
	}
    	return len ;
    }
    constexpr inline int xstrlen(cchar *sp) noex {
    	return intconv(strlen(sp)) ;
    }
    constexpr inline int xstrspn(cchar *sp,cchar *ss) noex {
    	return intconv(strspn(sp,ss)) ;
    }
    constexpr inline int xstrcspn(cchar *sp,cchar *ss) noex {
    	return intconv(strcspn(sp,ss)) ;
    }
    constexpr inline char *strcpy(char *dp,cchar *ss,int n) noex {
	char	*rp ;
	if (n >= 0) {
	    rp = stpncpy(dp,ss,n) ;
	} else {
	    rp = stpcpy(dp,ss) ;
	}
    	return rp ;
    } /* end subroutine (strcpy) */
    constexpr inline char *stpcpy(char *dp,cchar *ss,int n) noex {
	char	*rp ;
	if (n >= 0) {
	    rp = stpncpy(dp,ss,n) ;
	} else {
	    rp = stpcpy(dp,ss) ;
	}
    	return rp ;
    } /* end subroutine (stpcpy) */
} /* end export */

export {
    constexpr inline int memclear(void *objp,int sz) noex {
    	csize	objs = size_t(sz) ;
    	memset(objp,0,objs) ;
	return sz ;
    }
    template<typename T> constexpr inline int memclear(T *op) noex {
	cint	osz = szof(T) ;
	return memclear(op,osz) ;
    }
    template<typename T> constexpr inline void *memcpy(T *dp,cvoid *sp) noex {
	csize	dsize = sizeof(T) ;
	return memcpy(dp,sp,dsize) ;
    }
    template<typename T>
    constexpr inline void *cmemcpy(T *dp,cvoid *sp,size_t dsize = -1) noex {
    	if (dsize > INT_MAX) dsize = sizeof(T) ;
    	return memcpy(dp,sp,dsize) ;
    }
    constexpr inline void *memcopy(void *dp,cvoid *sp,int dsz) noex {
	caddr_t		rp ; /* return-value */
	if (dsz < 0) {
	    cchar *cp = ccharp(sp) ;
	    dsz = strlen(cp) ;
	}
	{
	    csize	dsize = size_t(dsz) ;
	    caddr_t	dst = caddr_t(dp) ;
	    memcpy(dp,sp,dsize) ;
	    rp = (dst + dsz) ;
	}
	return voidp(rp) ;
    } /* end subroutine (memcopy) */
    template<typename T>
    constexpr inline void *memcopy(T *dp,cvoid *sp,int dsz = -1) noex {
    	caddr_t		rp = nullptr ;
	if (rp && sp) {
    	    if (dsz < 0) dsz = szof(T) ;
	    rp = caddr_t(dp) ;
	    {
		csize dsize = size_t(dsz) ;
	        memcpy(dp,sp,dsize) ;
	        rp += dsz ;
	    }
	}
	return voidp(rp) ;
    } /* end subroutine (memcopy) */
    template<typename T>
    constexpr inline T *resumelife(void *vp) noex {
    	T *rp = cast_reinterpret<T *>(vp) ;
    	return rp ;
    }
} /* end export */


