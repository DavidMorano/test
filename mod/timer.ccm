/* timer MODULE (primary-module-interface) */
/* charset=ISO8859-1 */
/* lang=C++20 (conformance reviewed) */

/* TIMER object */
/* version %I% last-modified %G% */


/* revision history:

	= 1998-12-01, David A­D­ Morano
	This subroutine was written for Rightcore Network Services.

	= 2020-05-07, David A-D- Morano
	I converted this (formerly a header-only file) to a module.

*/

/* Copyright © 1998,2020 David A­D­ Morano.  All rights reserved. */

/*******************************************************************************

  	Module:
	timer

	Description:
        This object implments a simple time-out timer.

*******************************************************************************/

module ;

#include	<envstandards.h>	/* MUST be first to configure */
#include	<cstddef>		/* |nullptr_t| */
#include	<cstdlib>
#include	<new>			/* |nothrow(3c++| */
#include	<utility>
#include	<functional>
#include	<stdexcept>
#include	<usystem.h>
#include	<timeout.h>
#include	<localmisc.h>

export module timer ;

/* local defines */

#define	TIMER_DEFENTS	10


/* imported namespace */


/* local typedefs */


/* external subroutines */


/* external variables */


/* local structures */


/* forward references */


/* local variables */


/* exported stuff */

export {
    template<typename T> class timer {
	timeout		to ;
	T		objp = nullptr ;
	int		n = 0 ;
	int		at = 0 ;
	bool		f_running = false ;
   public:
	timer(T *aobjp) {
	    objp = aobjp ;
	    timeout_load(&to,0L,nullptr,nullptr,0u,0) ;
	} ; /* end ctor */
	destruct timer() {
	    if (f_running) {
	        cint	cmd = timeoutcmd_cancel ;
		f_running = false ;
		uc_timeout(cmd,&to) ;
	    }
	} ; /* end dtor */
	int setint(int valint,uint tag,int arg) {
	    cnullptr	np{} ;
	    int		rs = SR_OK ;
	    if (valint >= 0) {
	        custime		dt = time(nullptr) ;
	        if (f_running) {
	            cint	cmd = timeoutcmd_cancel ;
		    f_running = false ;
		    rs = uc_timeout(cmd,&to) ;
	        }
		if (rs >= 0) {
		    custime	valabs = (dt + valint) ;
		    rs = timeout_load(&to,valabs,np,np,tag,arg) ;
		}
	    } else {
		rs = SR_INVALID ;
	    }
	    return rs ;
	} ;
	int cancel() {
	    int		rs = SR_OK ;
	    if (f_running) {
	        cint	cmd = timeoutcmd_cancel ;
		f_running = false ;
		rs = uc_timeout(cmd,&to) ;
	    }
	    return rs ;
	} ;
    } ; /* end struct (timer) */
} /* end export */


