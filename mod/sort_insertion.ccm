/* sort_insertion MODULE (primary-module-interface) */
/* charset=ISO8859-1 */
/* lang=C++20 (conformance reviewed) */

/* insertion sort */
/* version %I% last-modified %G% */

#define	CF_RECURSE		1	/* use recursion */

/* revision history:

	= 2000-05-14, David A­D­ Morano
	Originally written for Rightcore Network Services.

	= 2013-07-23, David A­D­ Morano
	Updated to C++11, to get rid of stupid restriction on not
	having two adjacent '>' characters!

	= 2020-05-07, David A-D- Morano
	I converted this (formerly a header-only file) to a module.

*/

/* Copyright © 2000,2013,2020 David A­D­ Morano.  All rights reserved. */

/*******************************************************************************

  	Name:
	sort_insertion

	Description:
	This subroutine implements an inserion sort.

	+ in-place
	+ O(n^2)
	+ stable
	+ good for almost already sorted arrays
		O(n­k)
		when unsorted elements are no more than k places out
	+ space requirements: O(1)
	+ more efficient than other ineficient O(n^2) sorts, like
		bubble and selection
	+ best case: O(n), when array is already sorted

*******************************************************************************/

module ;

#include	<envstandards.h>	/* must be ordered first to configure */
#include	<cstddef>		/* |nullptr_t| */
#include	<cstdlib>
#include	<algorithm>		/* |greater(3c++)| */
#include	<functional>
#include	<clanguage.h>
#include	<utypedefs.h>
#include	<utypealiases.h>
#include	<usysdefs.h>

/* local defines */

#ifndef	CF_RECURSE
#define	CF_RECURSE	0		/* use recursion */
#endif

export module sort_insertion ;

using std::greater ;			/* subroutine-template */

constexpr bool		f_recurse = CF_RECURSE ;

export {
    template<typename T,typename Comp = std::greater<T>>
    int sort_interstionreg(T a,int n) {
	Comp	cmp ;
	int	i = 1 ;
	int	j ;
	T	x ;	/* target selection */
	while( i < n) {
	    x = a[i] ;
	    j = (i-1) ;
    	    while ((j >= 0) && cmp(a[j],x)) {
		a[j+1] = a[j] ;
		j -= 1 ;
	    }
	    a[j+1] = x ;
	    i += 1 ;
	} /* end while */
	return n ;
    } /* end subroutine (sort_insertion) */
    template<typename T,typename Comp = std::greater<T>>
    int sort_interstionrecurse(T a,int n,Comp &cmp) {
	if (n > 0) {
	    T		x ;	/* target selection */
	    int		j ;
	    sort_insertionrecurse(a,n-1,cmp) ;
	    x = a[n] ;
	    j = (n-1) ;
    	    while ((j >= 0) && cmp(a[j],x)) {
		a[j+1] = a[j] ;
		j -= 1 ;
	    } /* end while */
	    a[j+1] = x ;
	} /* end if */
	return n ;
    } /* end subroutine (sort_insertionrecurse) */
    template<typename T,typename Comp = std::greater<T>>
    int sort_insertion(T a,int n) {
    	int		rs = 0 ;
	if (n > 1) {
    	    if_constexpr (f_recurse) {
	        Comp	cmp ;
	        rs = sort_insertionrecurse(a,(n-1),cmp) ;
	    } else {
	        rs = sort_insertionreg(a,n) ;
	    }
	} /* end if (needed) */
	return rs ;
    } /* end subroutine (sort_insertion) */
} /* end export */


