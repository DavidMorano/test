/* digbufsizes MODULE */
/* encoding=ISO8859-1 */
/* lang=C++20 (conformance reviewed) */

/* provide buffer sizes for c-string digits */
/* version %I% last-modified %G% */


/* revision history:

	= 1998-11-01, David A­D­ Morano
	This subroutine was written for Rightcore Network Services.

	= 2025-04-29, David A­D­ Morano
	Now with constant-expression math (newly available w/ C++20
	I think), we can change this whole thing (constant database
	of values) to use a closed-form math calculation rather
	than the old repetitive divide algorithm.  The match functions
	used are |log2(3c++)| and |ceil(3c++)|, now both available
	in constant-expression form.  Why was not this done back
	in like 2020 (or earlier when constand-expression math first
	became available?  Who knows?  It takes time to review old
	code and update it in ways that were not originally obvious.

*/

/* Copyright © 1998,2025 David A­D­ Morano.  All rights reserved. */

/******************************************************************************* 
  	Name:
	digbufsizes

	Description:
	These subroutines facilitate determining buffer sizes for 
	various digits in different types and number bases.

	Notes:
	1. It is 2025 (see revision above) and it is (frankly)
	unbelievable how much simpler this whole thing became when
	using a closed-form match equation!  Just amazing!  How did
	the world work before constant-expression C++ math?  Also,
	use of a facility (of whatever sort and whatever provenance)
	to create maximum values of each integer type is now totally
	eliminated.  Previously, with the repetitive division
	algorithm, the maximum value for each integer type had to
	be used (or created id necessary) for input into the old
	algorithm.  Now that is not required with the new closed-form
	math alogorithm.  I hope that constant-expression C++ math
	is here to stay (and is available in all compilers that we
	care about) because I do not ever want to return to the
	older algorithm.  If we had to go back (if constant-expression
	math is never not avilable, I would rather change this whole
	thing into a non-constant-expression database than go back
	to the older (repetitive division) algorithm.
	2. Another note with this 2025 change: I have sort of broken
	the fourth wall as it were since I am now -- for the very first
	time -- using floating point math in any of this system or
	operating-system type of code.  In the old days, floating-point
	math (or arithmetic) was not availble in small or embedded
	environments.  So if I ever find myself, or rather if this code
	ever finds itself, in an environment where floating-point match
	is not availble, I am screwed (would not know immediately what
	to do).  I guess I would have to return this present code to
	using the old repetitive-division algorithm.

*******************************************************************************/

module ;

#include	<envstandards.h>	/* MUST be first to configure */
#include	<climits>		/* |{x}_MAX| + |CHAR_BIT| */
#include	<cmath>			/* |log2(3c++)| + |ceil(3c++)| */
#include	<clanguage.h>
#include	<utypedefs.h>
#include	<utypealiases.h>
#include	<usysdefs.h>
#include	<stdintx.h>

export module digbufsizes ;

export {
    constexpr int	digbufsizes_maxbase = 64 ; /* current max-base */
    constexpr int	digbufsizes_ntypes = 10 ; /* up to types w/ 1024 bits */
    constexpr int	digbufsizes_nbases = (digbufsizes_maxbase+1) ;
}

consteval int ndigs(int t,int b) noex {
	cdouble		fbase = cdouble(b) ;
	cdouble		fbits = cdouble((1 << t) * CHAR_BIT) ;
	return int(ceil(int(fbits / log2(fbase)))) ;
}

consteval int ndigits(int ntype,int base) noex {
    int             n = 0 ;
    if (base >= 2) {
	n = ndigs(ntype,base) ;
    } /* end if (valid base) */
    return n ;
} /* end subroutine (ndigits) */

export {
    struct digbufsizes {
	cint		nbases = digbufsizes_nbases ;
	cint		ntypes = digbufsizes_ntypes ;
	ushort		bufsize[digbufsizes_ntypes][digbufsizes_nbases] ;
	consteval digbufsizes() noex {
	    for (int b = 0 ; b < digbufsizes_nbases ; b += 1) {
	        for (int t = 0 ; t < digbufsizes_ntypes ; t += 1) {
		    bufsize[t][b] = ndigits(t,b) ;
	        }
	    }
	} ; /* end constructor (digbufsizes) */
    } ; /* end subroutine (digbufsizes) */
}


