/* digbufsizes MODULE (primary-module-interface) */
/* encoding=ISO8859-1 */
/* lang=C++20 (conformance reviewed) */

/* provide buffer sizes for c-string digits */
/* version %I% last-modified %G% */


/* revision history:

	= 1998-11-01, David A­D­ Morano
	This subroutine was written for Rightcore Network Services.

	= 2014-12-05, David A-D- Morano
	This code was converted from load-time initialization to
	compile-time initialization (using 'constexpr' compile-time
	execution).

	= 2023-10-16, David A­D­ Morano
	This code was "modularized" with the introduction of "modules"
	with C++20 (albeit a few years after the fact).

	= 2025-04-29, David A­D­ Morano
	Now with constant-expression math (newly available w/ C++20
	I think), we can change this whole thing (constant database
	of values) to use a closed-form math calculation rather
	than the old repetitive divide algorithm.  The math functions
	used are |log2(3c++)| and |ceil(3c++)|, now both available
	in constant-expression form.  Why was not this done back
	in like 2020 (or earlier when constand-expression math first
	became available)?  Who knows?  It takes time to review old
	code and update it in ways that were not originally available.

*/

/* Copyright © 1998,2014,2023,2025 David A­D­ Morano.  All rights reserved. */

/******************************************************************************* 
  	Name:
	digbufsizes

	Description:
	These subroutines facilitate determining buffer sizes (the
	number of characters corresponding to the number of digits
	in the maximum-values) for various different types (sizes)
	and number bases.  Hence a two dimensional array is setup
	that can be indexed by ineger (size) type and a base.  The
	type is given as the log-base-two of the number of bytes
	in the C++ integer type.  So (for example) the type |char|
	bas type-num equal to '0' (log-base-two of 1 is 0).  The
	type |short| has the type-num of '1'.  The type |int| has
	type-num of '2', et cetera.

	Notes:
	1. It is 2025 (see revision above) and it is (frankly)
	unbelievable how much simpler this whole thing became when
	using a closed-form math equation!  Just amazing!  How did
	the world work before constant-expression C++ math?  Also,
	use of a facility (of whatever sort and whatever provenance)
	to create maximum values of each integer type is now totally
	eliminated.  Previously, with the repetitive division
	algorithm, the maximum value for each integer type had to
	be used (or created if necessary) for input into the old
	algorithm.  Now that is not required with the new closed-form
	math alogorithm.  I hope that constant-expression C++ math
	is here to stay (and is available in all compilers that we
	care about) because I do not ever want to return to the
	older algorithm.  If we had to go back (if constant-expression
	math is ever not avilable), I would rather change this whole
	thing into a non-constant-expression database than go back
	to the older (repetitive division) algorithm.
	2. Another note with this 2025 change: I have sort of broken
	the fourth wall as it were since I am now -- for the very first
	time -- using floating point math in any of this system or
	operating-system type of code.  In the old days, floating-point
	math (or arithmetic) was not availble in small or embedded
	environments.  So if I ever find myself, or rather if this code
	ever finds itself, in an environment where floating-point math
	is not availble, I am screwed (would not know immediately what
	to do).  I guess I would have to return this present code to
	using the old repetitive-division algorithm.

*******************************************************************************/

module ;

#include	<envstandards.h>	/* MUST be first to configure */
#include	<climits>		/* |CHAR_BIT| */
#include	<cmath>			/* |log2(3c++)| + |ceil(3c++)| */
#include	<clanguage.h>
#include	<utypedefs.h>
#include	<utypealiases.h>
#include	<usysdefs.h>
#include	<stdintx.h>

export module digbufsizes ;

export {
    constexpr int	digbufsizes_maxbase = MAXBASE ; /* current max-base */
    constexpr int	digbufsizes_maxtype = 10 ; /* to types w/ 1024 bits */
    constexpr int	digbufsizes_nbases = (digbufsizes_maxbase+1) ;
}

consteval int ndigits(int t,int b) noex {
    int             n = 0 ;
    if (b >= 2) {
	cdouble		fbase = double(b) ;
	cdouble		fbits = double((1 << t) * CHAR_BIT) ;
	n = int(ceil(fbits / log2(fbase))) ;
    } /* end if (valid base) */
    return n ;
} /* end subroutine (ndigits) */

export {
    struct digbufsizes {
	cint		nbases = digbufsizes_nbases ;
	cint		ntypes = (digbufsizes_maxtype+1) ;
	ushort		bufsize[digbufsizes_maxtype+1][digbufsizes_nbases] ;
	consteval digbufsizes() noex {
	    for (int b = 0 ; b < digbufsizes_nbases ; b += 1) {
	        for (int t = 0 ; t < (digbufsizes_maxtype+1) ; t += 1) {
		    bufsize[t][b] = ndigits(t,b) ;
	        }
	    }
	} ; /* end constructor (digbufsizes) */
    } ; /* end subroutine (digbufsizes) */
} /* end export */


